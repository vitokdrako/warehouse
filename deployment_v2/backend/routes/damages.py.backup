"""
Damages Cabinet API - Кабінет шкоди PRO
"""
from fastapi import APIRouter, HTTPException, Depends
from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import func, or_, desc
from datetime import datetime
import uuid

from database import get_db
from models_sqlalchemy import DecorDamage, DecorDamageItem

router = APIRouter(prefix="/api/damages", tags=["damages"])


@router.get("/cases")
async def get_damage_cases(
    q: Optional[str] = None,
    status: Optional[str] = None,
    severity: Optional[str] = None,
    source: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    Отримати список кейсів шкоди з фільтрами
    """
    try:
        query = db.query(DecorDamage)
        
        # Фільтри
        if q:
            search_pattern = f"%{q}%"
            query = query.filter(
                or_(
                    DecorDamage.id.like(search_pattern),
                    DecorDamage.order_number.like(search_pattern),
                    DecorDamage.customer_name.like(search_pattern),
                    DecorDamage.event_name.like(search_pattern),
                    DecorDamage.notes.like(search_pattern)
                )
            )
        
        if status and status != 'all':
            query = query.filter(DecorDamage.case_status == status)
        
        if severity and severity != 'all':
            query = query.filter(DecorDamage.severity == severity)
        
        if source and source != 'all':
            query = query.filter(DecorDamage.source == source)
        
        # Сортування: новіші спочатку
        query = query.order_by(desc(DecorDamage.created_at))
        
        cases = query.all()
        
        result = []
        for case in cases:
            # Підрахунок sum з items
            items = db.query(DecorDamageItem).filter(
                DecorDamageItem.damage_id == case.id
            ).all()
            
            lines = []
            total_claimed = 0
            for item in items:
                line_total = float(item.estimate_value or 0) * (item.qty or 1)
                total_claimed += line_total
                lines.append({
                    'id': str(item.id),
                    'productName': item.name or '',
                    'sku': item.barcode or '',
                    'inventoryCode': item.item_ref or '',
                    'category': item.category or '',
                    'ruleLabel': item.damage_type or '',
                    'minAmount': float(item.base_value or 0),
                    'qty': item.qty or 1,
                    'amountPerUnit': float(item.estimate_value or 0),
                    'total': line_total,
                    'note': item.comment or '',
                    'fromReauditItemId': item.from_reaudit_item_id
                })
            
            result.append({
                'id': case.id,
                'orderId': case.order_number,
                'source': case.source or 'other',
                'fromReauditItemId': case.from_reaudit_item_id,
                'createdAt': case.created_at.isoformat() if case.created_at else None,
                'createdBy': case.created_by or 'Manager',
                'clientName': case.customer_name or 'Невідомий клієнт',
                'eventName': case.event_name,
                'returnDate': case.return_date.isoformat() if case.return_date else None,
                'severity': case.severity or 'medium',
                'status': case.case_status or 'draft',
                'depositHold': float(case.deposit_available or 0),
                'lines': lines,
                'internalNote': case.notes or '',
                'totalClaimed': total_claimed
            })
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Помилка завантаження кейсів: {str(e)}"
        )


@router.get("/cases/{case_id}")
async def get_damage_case(
    case_id: str,
    db: Session = Depends(get_db)
):
    """
    Отримати деталі одного кейсу
    """
    try:
        case = db.query(DecorDamage).filter(DecorDamage.id == case_id).first()
        
        if not case:
            raise HTTPException(status_code=404, detail="Кейс не знайдено")
        
        items = db.query(DecorDamageItem).filter(
            DecorDamageItem.damage_id == case.id
        ).all()
        
        lines = []
        total_claimed = 0
        for item in items:
            line_total = float(item.estimate_value or 0) * (item.qty or 1)
            total_claimed += line_total
            lines.append({
                'id': str(item.id),
                'productName': item.name or '',
                'sku': item.barcode or '',
                'inventoryCode': item.item_ref or '',
                'category': item.category or '',
                'ruleLabel': item.damage_type or '',
                'minAmount': float(item.base_value or 0),
                'qty': item.qty or 1,
                'amountPerUnit': float(item.estimate_value or 0),
                'total': line_total,
                'note': item.comment or '',
                'fromReauditItemId': item.from_reaudit_item_id
            })
        
        return {
            'id': case.id,
            'orderId': case.order_number,
            'source': case.source or 'other',
            'fromReauditItemId': case.from_reaudit_item_id,
            'createdAt': case.created_at.isoformat() if case.created_at else None,
            'createdBy': case.created_by or 'Manager',
            'clientName': case.customer_name or 'Невідомий клієнт',
            'eventName': case.event_name,
            'returnDate': case.return_date.isoformat() if case.return_date else None,
            'severity': case.severity or 'medium',
            'status': case.case_status or 'draft',
            'depositHold': float(case.deposit_available or 0),
            'lines': lines,
            'internalNote': case.notes or '',
            'totalClaimed': total_claimed
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Помилка: {str(e)}"
        )


@router.post("/cases")
async def create_damage_case(
    data: dict,
    db: Session = Depends(get_db)
):
    """
    Створити новий кейс шкоди
    """
    try:
        case_id = f"DC-{uuid.uuid4().hex[:8].upper()}"
        
        new_case = DecorDamage(
            id=case_id,
            order_id=data.get('order_id'),
            order_number=data.get('order_number'),
            customer_id=data.get('customer_id'),
            customer_name=data.get('customer_name', 'Невідомий клієнт'),
            customer_phone=data.get('customer_phone'),
            customer_email=data.get('customer_email'),
            event_name=data.get('event_name'),
            return_date=datetime.fromisoformat(data['return_date']) if data.get('return_date') else None,
            case_status=data.get('status', 'draft'),
            severity=data.get('severity', 'medium'),
            source=data.get('source', 'other'),
            from_reaudit_item_id=data.get('from_reaudit_item_id'),
            deposit_available=data.get('deposit_hold', 0),
            notes=data.get('internal_note', ''),
            created_by=data.get('created_by', 'Реквізитор')
        )
        
        db.add(new_case)
        db.commit()
        
        return {
            'success': True,
            'case_id': case_id,
            'message': 'Кейс створено'
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Помилка створення кейсу: {str(e)}"
        )


@router.put("/cases/{case_id}/status")
async def update_case_status(
    case_id: str,
    data: dict,
    db: Session = Depends(get_db)
):
    """
    Оновити статус кейсу
    """
    try:
        case = db.query(DecorDamage).filter(DecorDamage.id == case_id).first()
        
        if not case:
            raise HTTPException(status_code=404, detail="Кейс не знайдено")
        
        case.case_status = data.get('status', case.case_status)
        
        db.commit()
        
        return {
            'success': True,
            'message': 'Статус оновлено'
        }
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Помилка: {str(e)}"
        )


@router.post("/cases/{case_id}/lines")
async def add_damage_line(
    case_id: str,
    data: dict,
    db: Session = Depends(get_db)
):
    """
    Додати позицію в кейс
    """
    try:
        case = db.query(DecorDamage).filter(DecorDamage.id == case_id).first()
        
        if not case:
            raise HTTPException(status_code=404, detail="Кейс не знайдено")
        
        new_item = DecorDamageItem(
            damage_id=case_id,
            product_id=data.get('product_id'),
            from_reaudit_item_id=data.get('from_reaudit_item_id'),
            barcode=data.get('sku', ''),
            name=data.get('product_name', ''),
            category=data.get('category', 'Реквізит'),
            item_ref=data.get('inventory_code'),
            damage_type=data.get('rule_label', 'Пошкодження'),
            qty=data.get('qty', 1),
            base_value=data.get('min_amount', 0),
            estimate_value=data.get('amount_per_unit', 0),
            comment=data.get('note', '')
        )
        
        db.add(new_item)
        db.commit()
        
        return {
            'success': True,
            'line_id': new_item.id,
            'message': 'Позицію додано'
        }
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Помилка: {str(e)}"
        )


@router.put("/cases/{case_id}/lines/{line_id}")
async def update_damage_line(
    case_id: str,
    line_id: str,
    data: dict,
    db: Session = Depends(get_db)
):
    """
    Оновити позицію в кейсі
    """
    try:
        item = db.query(DecorDamageItem).filter(
            DecorDamageItem.id == int(line_id),
            DecorDamageItem.damage_id == case_id
        ).first()
        
        if not item:
            raise HTTPException(status_code=404, detail="Позицію не знайдено")
        
        if 'amount_per_unit' in data:
            item.estimate_value = data['amount_per_unit']
        if 'qty' in data:
            item.qty = data['qty']
        if 'note' in data:
            item.comment = data['note']
        
        db.commit()
        
        return {
            'success': True,
            'message': 'Позицію оновлено'
        }
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Помилка: {str(e)}"
        )


@router.put("/cases/{case_id}")
async def update_damage_case(
    case_id: str,
    data: dict,
    db: Session = Depends(get_db)
):
    """
    Оновити інформацію про кейс
    """
    try:
        case = db.query(DecorDamage).filter(DecorDamage.id == case_id).first()
        
        if not case:
            raise HTTPException(status_code=404, detail="Кейс не знайдено")
        
        if 'internal_note' in data:
            case.notes = data['internal_note']
        if 'severity' in data:
            case.severity = data['severity']
        if 'status' in data:
            case.case_status = data['status']
        
        db.commit()
        
        return {
            'success': True,
            'message': 'Кейс оновлено'
        }
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Помилка: {str(e)}"
        )
