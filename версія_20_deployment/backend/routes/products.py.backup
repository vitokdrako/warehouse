"""
Products API - Створення та управління товарами
"""
from fastapi import APIRouter, HTTPException, Depends, UploadFile, File
from sqlalchemy.orm import Session
from sqlalchemy import text
from datetime import datetime, timedelta
import uuid
import os
import base64

from database import get_db

router = APIRouter(prefix="/api/products", tags=["products"])

# Директорія для збереження фото
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
UPLOAD_DIR = os.path.join(BASE_DIR, "uploads", "products")
os.makedirs(UPLOAD_DIR, exist_ok=True)


@router.post("/upload-image")
async def upload_product_image(
    file: UploadFile = File(...)
):
    """
    Завантажити фото товару
    """
    try:
        # Перевірити тип файлу
        allowed_types = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp']
        if file.content_type not in allowed_types:
            raise HTTPException(
                status_code=400,
                detail=f"Дозволені тільки зображення: JPG, PNG, WEBP"
            )
        
        # Перевірити розмір (макс 5MB)
        contents = await file.read()
        if len(contents) > 5 * 1024 * 1024:
            raise HTTPException(
                status_code=400,
                detail="Розмір файлу не повинен перевищувати 5MB"
            )
        
        # Генерувати унікальне ім'я файлу
        file_ext = file.filename.split('.')[-1] if '.' in file.filename else 'jpg'
        unique_filename = f"{uuid.uuid4().hex[:12]}.{file_ext}"
        file_path = os.path.join(UPLOAD_DIR, unique_filename)
        
        # Зберегти файл
        with open(file_path, 'wb') as f:
            f.write(contents)
        
        # Повернути шлях для збереження в базі
        relative_path = f"uploads/products/{unique_filename}"
        
        return {
            'success': True,
            'filename': unique_filename,
            'path': relative_path,
            'url': f"/uploads/products/{unique_filename}",
            'size': len(contents)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Помилка завантаження фото: {str(e)}"
        )


@router.post("/create")
async def create_product(
    data: dict,
    db: Session = Depends(get_db)
):
    """
    Створити новий товар через кабінет переобліку
    """
    try:
        # 1. Створити запис в oc_product
        product_insert = text("""
            INSERT INTO oc_product (
                model, sku, quantity, status, price, 
                date_added, date_modified, image
            )
            VALUES (
                :model, :sku, :quantity, 1, :price,
                NOW(), NOW(), :image
            )
        """)
        
        model = data.get('code', f"NEW-{uuid.uuid4().hex[:8].upper()}")
        sku = data.get('sku', model)
        
        result = db.execute(product_insert, {
            'model': model,
            'sku': sku,
            'quantity': data.get('quantity', 1),
            'price': data.get('price', 0),
            'image': data.get('image', '')
        })
        
        # Отримати ID створеного продукту
        product_id = result.lastrowid
        
        # 2. Створити опис товару
        description_insert = text("""
            INSERT INTO oc_product_description (
                product_id, language_id, name, description,
                meta_title, meta_description, meta_keyword, tag
            )
            VALUES (
                :product_id, 4, :name, :description,
                :name, '', '', ''
            )
        """)
        
        db.execute(description_insert, {
            'product_id': product_id,
            'name': data.get('name', 'Новий товар'),
            'description': data.get('description', '')
        })
        
        # 3. Додати атрибути (колір, матеріал)
        if data.get('color'):
            db.execute(text("""
                INSERT INTO oc_product_attribute (product_id, attribute_id, language_id, text)
                VALUES (:product_id, 11, 4, :color)
            """), {'product_id': product_id, 'color': data['color']})
        
        if data.get('material'):
            db.execute(text("""
                INSERT INTO oc_product_attribute (product_id, attribute_id, language_id, text)
                VALUES (:product_id, 12, 4, :material)
            """), {'product_id': product_id, 'material': data['material']})
        
        if data.get('care_instructions'):
            db.execute(text("""
                INSERT INTO oc_product_attribute (product_id, attribute_id, language_id, text)
                VALUES (:product_id, 17, 4, :care)
            """), {'product_id': product_id, 'care': data['care_instructions']})
        
        # 4. Створити запис в decor_inventory_items (автоматично переоблікований)
        inventory_id = f"INV-{product_id}"
        inventory_insert = text("""
            INSERT INTO decor_inventory_items (
                id, product_id, inventory_code, status,
                last_audit_date, last_audit_by, audit_status,
                next_audit_date, created_at, updated_at
            )
            VALUES (
                :id, :product_id, :inventory_code, 'available',
                CURDATE(), :audited_by, 'ok',
                DATE_ADD(CURDATE(), INTERVAL 180 DAY), NOW(), NOW()
            )
        """)
        
        db.execute(inventory_insert, {
            'id': inventory_id,
            'product_id': product_id,
            'inventory_code': data.get('inventory_code', f'INV-{product_id}'),
            'audited_by': data.get('created_by', 'Реквізитор')
        })
        
        # 5. Створити запис переобліку в історії
        audit_id = f"AUDIT-{uuid.uuid4().hex[:8].upper()}"
        audit_insert = text("""
            INSERT INTO decor_product_audits (
                id, product_id, inventory_item_id,
                audit_date, audited_by, audit_status, audit_notes
            )
            VALUES (
                :audit_id, :product_id, :inventory_id,
                CURDATE(), :audited_by, 'ok', :notes
            )
        """)
        
        db.execute(audit_insert, {
            'audit_id': audit_id,
            'product_id': product_id,
            'inventory_id': inventory_id,
            'audited_by': data.get('created_by', 'Реквізитор'),
            'notes': f"Новий товар додано через переоблік. Категорія: {data.get('category', 'Загальне')}"
        })
        
        # 6. Якщо є категорія, додати в decor_product_catalog
        if data.get('category') or data.get('location_zone') or data.get('location'):
            catalog_insert = text("""
                INSERT INTO decor_product_catalog (
                    product_id, category, subcategory,
                    location_zone, location_aisle, location_shelf
                )
                VALUES (
                    :product_id, :category, :subcategory,
                    :zone, :aisle, :shelf
                )
            """)
            
            # Розбити категорію на основну і підкатегорію
            category_full = data.get('category', 'Загальне')
            if ' · ' in category_full:
                parts = category_full.split(' · ')
                category = parts[0].strip()
                subcategory = parts[1].strip() if len(parts) > 1 else ''
            else:
                category = category_full
                subcategory = data.get('subcategory', '')
            
            # Розбити локацію
            location = data.get('location', '')
            location_parts = location.split('/')
            aisle = location_parts[0].strip() if len(location_parts) > 0 else ''
            shelf = location_parts[1].strip() if len(location_parts) > 1 else ''
            
            db.execute(catalog_insert, {
                'product_id': product_id,
                'category': category,
                'subcategory': subcategory,
                'zone': data.get('location_zone', 'A'),
                'aisle': aisle,
                'shelf': shelf
            })
        
        db.commit()
        
        return {
            'success': True,
            'product_id': product_id,
            'item_id': f'A-{product_id}',
            'message': f'Товар "{data.get("name")}" створено та переоблікований',
            'audit_id': audit_id
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Помилка створення товару: {str(e)}"
        )


@router.get("/categories")
async def get_categories(
    db: Session = Depends(get_db)
):
    """
    Отримати список категорій для dropdown
    """
    try:
        # Отримати унікальні категорії з існуючих товарів
        result = db.execute(text("""
            SELECT DISTINCT category
            FROM decor_product_catalog
            WHERE category IS NOT NULL AND category != ''
            ORDER BY category
        """))
        
        categories = [row[0] for row in result if row[0]]
        
        # Якщо немає категорій, повернути базові
        if not categories:
            categories = ['Вази', 'Меблі', 'Свічники', 'Декор', 'Текстиль', 'Освітлення']
        
        return {'categories': categories}
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Помилка: {str(e)}"
        )
